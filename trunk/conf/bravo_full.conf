# rtmfp server config for bravo.
# for open-source project, @see full.conf for detail config.
# for non-compatible changes, @read https://github.com/laolei2016/bms4upyun/blob/api/develop/Compatible.md

#############################################################################################
# Global sections
#############################################################################################
listen              1935;
max_connections     1000;
# default: 4096
chunk_size          4096;

# bravo log file, when bms start, it will replace the [pid] with srs process id.
srs_log_file        ./objs/upc_origin[pid].log;

# the work dir for server, to chdir(work_dir) when not empty or "./"
# user can config this directory to change the dir.
# @reamrk do not support reload.
# default: ./
work_dir ./;

# whether enable fast connect,
# to set TCP_NODELAY to 1 and response little info.
# we will group some small packets, for instance, connect, set ack size, bwDone
# use cork on then group them to big tcp packet then cork off to send.
# default: on
fast_connect_for_rtmp   on;

# whether quit when parent process changed,
# used for supervisor mode(not daemon), srs should always quit when 
# supervisor process exited.
# @remark conflict with daemon, error when both daemon and asprocess are on.
# @reamrk do not support reload.
# default: off
asprocess off;

# when f4_bms_port on, whether use the specified port. 
# for example, when oryx proxy the hls+ stream, we always use the oryx port.
# @remark oryx proxy must set this port to http stream port.
# if 0, use the http stream port.
# default: 0
f4_hls_plus_port 8080;

# the time up in seconds for upgrade, force server to quit when time up.
# for example, 1day(86400s), 3days(259200), 5days(432000), 7days(604800),
# or 24hours(86400), 12hours(43200), 8hours(28800), 4hours(14400), 1hour(3600),
# or 60minutes(3600), 30minutes(1800), 15minutes(900), 5minutes(300)
# default: 86400
# @remark when upgrade ok, server will remove the srs.pid file.
# @remark when srs.pid exists but process quit, the upgrade must be failed.
# @remark we only need to upgrade the edge, for origin or upstream edge, we can directly 
#       restart them for the edge will retry.
upgrade_timeup 86400;

# the license file for bravo server.
license {
    # the storage type of license:
    #       file, use license file specified by path.
    #       network, use network system licenser(https://notehub.org/6gnca)
    # default: file
    storage         file;
    # for file storage, the path for license file.
    # default: ./objs/license.txt
    path            ./objs/license.txt;
    # for network storage, the api to query and verify license.
    # default: http://127.0.0.1:8085/api/v1/license
    api             http://127.0.0.1:8085/api/v1/license;
    # for network storage, the key is customer token issued by licener
    # which used to identify the customer of bravo license system.
    token           35c9b402c12a7246868752e2878f7e0e;
    # for network storage, the salt issued by customer system,
    # which will veify by customer system by callback to licenser.
    salt            35c9b402c12a7246868752e2878f7e0e;
}

# bravo add more match rules to choose the public ip address from networks.
stats {
    # the rule to choose the best public address
    # from multiple local addresses.
    #
    # nnme(network name match except) used to match the network without this name.
    # for example, there are eth0 and eth0:8, both has internet address,
    # we will use eth0 when nnme set to ':' to choose which not contains ':'.
    # default: ':'
    nnme            ':';
}

# whether enable the vhost redirect,
# bms can support:
#             rtmp://www.sina.com/app/stream
#
#             rtmp://ip:port/app__www.sina.com/stream
#             rtmp://ip:port/app?vhost=www.sina.com/stream
#             rtmp://ip:port/app...vhost...www.sina.com/stream
#
#             rtmp://ip:port/www.sina.com/app/stream
#
#             rtmp://ip:port/app/stream?domain=www.sina.com
#             rtmp://ip:port/app/stream?vhost=www.sina.com
# the standard url:
#             rtmp://ip:port/app/stream?vhost=www.sina.com
# @remark vhost_redirect_enabled always on.

#############################################################################################
# Bravo alias
#############################################################################################
vhost with-alias.srs.com {
    # alias for current vhost, must be unique in global.
    # support multiple alias, separated by space,
    # for example, alias-1.com alias-2.com
    # @remark upyun use cluster.vhost, no need alias anymore.
    alias    alias-1.com alias-2.com;
}
  
#############################################################################################
# upyun cluster sections
#############################################################################################
up_cluster {
    # whether upyun cluster is enalbed.
    # on means that all vhost will generate dynamically.
    # default: off
    enabled           off;
    # the role of this server in upyun cluster, origin/transfer/edge.
    #       origin  : means that all dynamic vhosts will be the origin vhosts, which provides stream source for transfer server.
    #       transfer: means that all dynamic vhosts will be the edge vhosts, which pull/push to origin server.
    #       edge    : means that all dynamic vhosts will be the edge vhosts, which pull/push to transfer server.
    # default: origin
    role              edge;
    # for transfer(role transfer), user must specifies the origin server
    # for edge(role edge), user must specifies the transfer server
    # format as: <server_name|ip>[:port]
    # @remark user can specifies multiple origin for error backup, by space,
    # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935
    # @remark for transfer/edge only.
    origin            127.0.0.1:19360;
    # when play connection disconnect, srs will report connection info to this api.
    # @remark about the response, see research/api-server/upyun-server.py
    # @remark for edge only.
    on_disconnect     http://127.0.0.1:8086/api/v1/logs;
}

#############################################################################################
# bravo config system section
#############################################################################################
# when enable the config system, we will use network config instead config file.
# for example, when player access the vhost on edge server, the edge will read config
# from config system and add the vhost config dynamically.
bitch {
    # whether enabled the config system.
    enabled         off;
    # the api server for bitch, 
    #   query, for origin/edge to query the config info.
    #   update, for origin to update the domains which needs to.
    api             http://127.0.0.1:2018/api/v1/bitch;
    # the bitch(bravo innovative technical config handler) startup command.
    # server will fork a process to run the api and quit when it terminated.
    # @remark user can specifies the stdout and stderr by 1>file and 2>file.
    cmd             ./objs/bitch --listen=127.0.0.1:2018 --redis=redis://127.0.0.1:6379 1>/dev/null 2>/dev/null;
    # the default expire for each vhost config.
    # the expire can be set in config, use this value if not specified.
    expire          300;
    # the interval in seconds for origin to fetch config.
    # @remark for origin only.
    # default 120
    interval        120;
    # the ffmpeg dir to genearete the ingester.
    # @remark for origin only, which will pull stream.
    # default: ./objs/ffmpeg/bin/ffmpeg
    ffmpeg            ./objs/ffmpeg/bin/ffmpeg;
}

#############################################################################################
# bravo origin cluster section
#############################################################################################
# when origin servers connected as origin cluster,
# all edges connect to origin, will be redirect to the "right" origin.
# this is very useful when there are millions of streams to devliery,
# we must dispatch some stream to some server, rather than all streams to one origin,
# when edge connect to a origin which not serve the required stream,
# this origin server will redirect the edge to the right one.
# @remark the origin cluster will error when stream is not publishing
#           which means no origin own the stream.
bocar {
    # whether enable the origin cluster.
    # default: off
    enabled         off;
    # the api server for origin cluster,
    # to query and update the stream info of origin.
    api             http://127.0.0.1:2016/api/v1/bocar;
    # the bocar(bravo origin cluster api over redis) startup command.
    # server will fork a process to run the api and quit when it terminated.
    # @remark user can specifies the stdout and stderr by 1>file and 2>file.
    bocar           ./objs/bocar --listen=127.0.0.1:2016 --rredis=redis://127.0.0.1:6379 --wredis=redis://127.0.0.1:6379 1>/dev/null 2>/dev/null;
    # the heartbeat interval in seconds.
    # server will update the stream info every this seconds.
    # when bocar backend(for example, redis server) crash, the origin cluster
    # can rebuild by heartbeat, which create or update the stream info.
    # default: 300
    heartbeat       300;
}

vhost bocar.with.backup {
    bocar {
        # whether enabled stream backup
        # when enable the backup, bocar can accept 1+ streams with the same uri.
        # otherwise publish failed when stream duplicated.
        # default: off
        backup      off;
    }
}

#############################################################################################
# bravo non-blocking dns section
#############################################################################################
# the dns lookup for RO(reverse-proxy origin) use system gethostbyname(), which is blocking
# api and cause ST to blocked. we use a process to do the dns resolve, the bravo 
# non-blockding dns api.
dns {
    # whether enable the non-blocking dns.
    # default: off
    enabled         off;
    # the api server for bravo non-blocking dns,
    # to query dns of origin.
    api             http://127.0.0.1:2024/api/v1/dns;
    # the dns(bravo non-blocking dns api) startup command.
    # server will fork a process to run the api and quit when it terminated.
    # @remark user can specifies the stdout and stderr by 1>file and 2>file.
    # ignore when empty.
    dns            ./objs/bravo_dns --listen=127.0.0.1:2024 1>/dev/null 2>/dev/null;
}

#############################################################################################
# bravo transcode cluster section
#############################################################################################
# for origin server, when access some streams which matched, create task at bravo transcode 
# cluster. The task will pull the source stream, transcode it and then publish to the origin 
# server again.
bott {
    # whether transcode the matched stream.
    # default: off
    enabled         on;
    # the url to CRUD the task to transcode cluster.
    # @remark bms should use bott proxy api(never directly access the transcode system), to do cleanup.
    url             http://127.0.0.1:2041/api/v1/job?api_key=e36f257bdcc554cdc3c609b904024734;
    # the transcode params for engine.
    engine {
        # the provider which provide the params, can be:
        #       inside use preset as transcode param.
        #       api use http api to get transcode param
        # default: inside
        provider    inside;
        # for inside preset, use some preloaded engines, for example:
        #       fast, medium, slow
        # default: fast
        preset      fast;
        # for http api provider, use this address to get transcode param
        api         http://127.0.0.1:2041/api/v1/bott;
    }
    # the bott startup command.
    # server will fork a process to run the api and quit when it terminated.
    # @remark user can specifies the stdout and stderr by 1>file and 2>file.
    cmd     ./objs/bott --listen=127.0.0.1:2041 1>/dev/null 2>/dev/null;
    # the rule to match the stream which need to be transcode.
    # @remark sepcified by the bott in each vhost.
}
vhost bott.bravo.com {
    # the rule for bott to match streams.
    bott {
        # whether enable the bott rule.
        # default: false
        enabled     off;
        # the match scope, which can be:
        #       stream when stream match the rule, transcode it.
        # default: stream
        scope       stream;
        # the match rulers, which can be:
        #       suffix when stream suffix with specified args, transcode it.
        match       suffix -small;
    }
}

#############################################################################################
# bravo ingest section
#############################################################################################
vhost bravo.ingester.com {
    # the bravo ingest, to ingest many streams to srs.
    # use the specified ffmpeg and use input file as config file.
    # @see ./objs/bravo_ingest and ./conf/bravo_ingest_urls.conf
    ingest bingest {
        enabled      off;
        input {
            type    file;
            url     ./conf/bravo_ingest_urls.conf;
        }
        ffmpeg      ./objs/bravo_ingest;
        engine {
            output  rtmp://127.0.0.1;
        }
    }
}

#############################################################################################
### http billing sections
#############################################################################################
### report billing info to api server
### @remark, the ip report to server
http_billing {
    # whether http billing is enalbed.
    # default: off
    enabled         off;
    # the interval seconds for http billing.
    # default: 300
    interval        300;
    # when startup, srs will report billing info to this api.
    # @remark: must be a restful http api url, where SRS will POST with following data:
    #   {
    #       "kw.ossrs.net": {
    #           "count": 1022, // all online clients of this vhost, include publish and play
    #           "in_bytes": 35672, // srs receive bytes from last report to now
    #           "out_bytes": 12345 // srs send bytes bytes from last report to now
    #       },
    #       "cc.ossrs.net": {
    #           "count": 52,
    #           "in_bytes": 372,
    #           "out_bytes": 0
    #       }
    #   }
    url             http://127.0.0.1:8086/api/v1/billings;
}

#############################################################################################
##" big data statistic sections
#############################################################################################
### report big data statistic info to api server
big_data {
    # whether big_data statistic is enalbed.
    # default: off
    enabled         off;
    # the big api url, post data to the url
    url             http://127.0.0.1:2019/api/v1/big_data/log?key=35c9b402c12a7246868752e2878f7e0e;
    # the big startup command.
    # server will fork a process to run the api and quit when it terminated.
    # @remark user can specifies the stdout and stderr by 1>file and 2>file.
    cmd         ./objs/big_api --listen=:2019 --by=bravo 1>/dev/null 2>/dev/null;
}

#############################################################################################
## bss sections
#############################################################################################
### bms do security check.
bss {
    # whether bss is enabled.
    # default: off
    enabled off;
    # the bss api url, post data to the url
    url  http://127.0.0.1:2048/api/v1/bss/check?key=35c9b402c12a7246868752e2878f7e0e;
    # the bss startup cmd.
    cmd ./objs/bss --listen=:2048 1>/dev/null 2>/dev/null;
}

#############################################################################################
# RTMFP sections
#############################################################################################
rtmfp {
    # whether the rtmfp is enabled.
    # default: off
    enabled     on;
    # the udp bind port.
    # @remark, only support single port.
    # default: 1935
    listen      1935;
    # when exceed the max sessions, follow this strategy.
    # when exceed the max connections, direct drop packet.
    overload_strategy {
        # max sessions for rtmfp, which must < max_connections
        # when exceed this max sessions, overload.
        # default: 15000
        max_sessions    10000;
        # when overload(exceed the max_sessions), the strategy to use.
        #       redirect    redirect client to other server.
        #       reject      accept then response a reject messsage, peer will got reject.
        #       drop        directly drop packet, peer will timeout.
        #       off         turn strategy off, ignore overload and service the peer.
        # default: reject
        strategy        reject;
        # when redirect, the address(ip:port) to redirect to.
        # @remark, lo interface(127.0.0.1 or localhost) will be replaced by public/private ip.
        # for example, 127.0.0.1:1936 or 192.168.1.173:1936
        redirect_to     127.0.0.1:1936;
    }
    # seconds to determine server is alive
    # default: 15
    keep_alive_server 15;
    # seconds to determine peer is alive
    # default: 10
    keep_alive_peer 10;
    # peer timeout to remove peer, in seconds. the client timeout data:
    # [2014-08-23 17:24:22.278][warns][100] drop session 1
    # [2014-08-23 17:26:11.031][warns][100] drop session 1
    # default: 100
    peer_timeout 100;
    # update server stat interval, in seconds
    # default: 10
    stat_interval 10;
    # whether disable the ssl encrypt/decrypt, use plaintext,
    # for performance bentchmark.
    # @remark only for test, never disable for online service.
    # default: off
    disable_ssl off;
    # bravo tracker
    # whether disable the bravo tracker, default is off
    # if it is "off" client will use http tracker
    # if it is "on" client will use bravo tracker
    # default: off
    bravo_tracker off;
    # tracker_url
    # if bravo_tracker is on, the tracker url will point to bravo tracker address:port
    tracker_url 127.0.0.1:1998;
}

#############################################################################################
## vhost sections with hls
##############################################################################################
vhost with.hls.bravo.com {
    hls {
        # the error strategy. canbe:
        #       ignore, disable the hls.
        #       disconnect, require encoder republish.
        #       continue, ignore failed try to continue output hls.
        # @see https://github.com/ossrs/srs/issues/264
        # default: ignore
        hls_on_error    ignore;
        
        # how many segments we will keep in expire queue.
        # that is, although the segments removed from m3u8,
        # but we can access the ts segment.
        # default: 10
        hls_expire      10;
        
        # we ensure the td never overflow than segments, so change to 1.0
        # default: 1.0
        hls_td_ratio    1.0;
    }
}

#############################################################################################
## vhost sections with hls, support bravo p2p.
##############################################################################################
vhost p2p.hls.bravo.com {
    hls {
        enabled         on;
        hls_fragment    3;
        hls_window      600;
        hls_path        ./objs/nginx/html;
        hls_m3u8_file   [app]/[stream]/live.m3u8;
        hls_ts_file     [app]/[stream]/[2006]-[01]-[02]/[15]/[timestamp].ts;
        hls_ts_floor    on;
        hls_aof_ratio   10;
        hls_cleanup     on;
        hls_on_error    disconnect;
        hls_nb_notify   1048576;
        hls_wait_keyframe       off;
    }
}

#############################################################################################
## vhost sections with hls, support bravo drm.
##############################################################################################
vhost hls.with.drm.bravo.com {
    hls {
        enabled         on;
        # drm algorithms:
        #     [group1]:
        #         panda: with 5bytes(0x50, 0x41, 0x4e, 0x44, 0x41) at the beginning of the segment.
        #         mycat: with 5bytes(0x4d, 0x59, 0x43, 0x41, 0x54) at the beginning of the segment.
        #     [group2]:
        #         tiger: replace the standard sync byte(0x47) of ts segment to 0x74.
        #
        # Attention: 
        #     support multiple algorithm, separated by space.
        #     every algorithm in every group can be used independently.
        #     algorithms in [group1] are mutually exclusive.
        #     but algorithm in [group1] can be used with algorithm in [group2].
        # for example: 
        #     hls_drm    mycat tiger; # [group1] + [group2]
        #     hls_drm    panda;       # only [group1]
        #     hls_drm    tiger;       # only [group2]
        hls_drm         panda;
    }
}

#############################################################################################
## vhost sections for http flv origin server.
##############################################################################################
vhost http.flv.origin.bravo.com {
    cluster {
        # the mode and origin defined by srs.
        mode        remote;
        origin      192.168.1.10;
        
        # the transport to origin, rtmp or http.
        # default: rtmp
        transport   http;
        
        # the stream muxer of origin, rtmp or flv or hls.
        # @remark for hls-cup, read hls.cup.origin
        # default: rtmp
        muxer       flv;
        
        # the referer for rtmp or http.
        # use client request referer if not set.
        referer     http://www.panda.tv;
        
        # the extension for http transport.
        # @remark for hls-cup, read hls.cup.origin
        # default:
        #       .flv for muxer flv streaming.
        #       .m3u8 for muxer hls streaming.
        extension   .flv;
    }
}

#############################################################################################
## the vhost for refer
# ############################################################################################
vhost refer.com {
    # refer hotlink-denial.
    refer {
        # whether enable the refer hotlink-denial.
        # default: off.
        enabled         on;
        # the common refer for play and publish.
        # if the page url of client not in the refer, access denied.
        # if not specified this field, allow all.
        # there are some configures for refer, domain represents hosts like "github.com":
        #   1. [NULL] is for empty refer.
        #   2. [domain] is for wildcard refer.
        #   3. domain is for exact refer.
        # default: not specified.
        all           github.com github.io [bravovcloud.com] [NULL];
        # refer for publish clients specified.
        # the common refer is not overridden by this.
        # if not specified this field, allow all.
        # there are some configures for refer, domain represents hosts like "github.com":
        #   1. [NULL] is for empty refer.
        #   2. [domain] is for wildcard refer.
        #   3. domain is for exact refer.
        # default: not specified.
        publish   github.com github.io;
        # refer for play clients specified.
        # the common refer is not overridden by this.
        # if not specified this field, allow all.
        # there are some configures for refer, domain represents hosts like "github.com":
        #   1. [NULL] is for empty refer.
        #   2. [domain] is for wildcard refer.
        #   3. domain is for exact refer.
        # default: not specified.
        play      github.com github.io;
    }
}

#############################################################################################
## the cluster to choose vhost for upstream
##############################################################################################
# for all flv/rtmp edge, 
#       use transform vhost, 
#       then follow vhost(req->vhost), 
#       finally use origin ip or host as vhost.
vhost upstream.bravo.com {
    cluster {
        mode        remote;

        # the transform vhost for upstream vhost.
        # @reamrk ignore when transform vhost is empty.
        # default: empty
        vhost       example.com;

        # whether follow the vhost in request.
        # @remark ignore when off.
        # default: on
        follow_vhost    on;
        
        # the origin ip or host.
        # @remark use as vhost when both transform and follow vhost is off.
        origin      192.168.1.10;
    }
}

#############################################################################################
## vhost sections for hls-cup(hls concurrency upstream) origin server.
##############################################################################################
vhost hls.cup.origin.bravo.com {
    cluster {
        # the mode and origin defined by srs.
        mode        remote;
        # the origin server hostport.
        # for the hls-cup, maybe fetch by multiple thread from one(or multiple) origins.
        # so we duplicate the origin here as sample.
        origin      192.168.1.10 192.168.1.10;
        transport   http;
        # the muxer should be hls for hls-cup.
        # @remark the hls-cup will make more latency for we must wait for a piece to ok and parse it.
        #       it will cause more problem, for example, when we got one whole piece, we should not
        #       send the whole parsed piece to client(for it may drop frames and cause more latency),
        #       instead we must send some messages then more, however, it also hurts performance and
        #       make the system more complex and make more latency.
        muxer       hls;
        extension   .m3u8;
        # the to(timeout)r(ratio) for hls cup to wait for message,
        # generally the to set to a const-to(for instance, 9s) for edge ingester,
        # and change to the td(target duration) when m3u8 parsed(for instance, 15s) if larger.
        # this ratio used to control the timeout, when network is bad, use larger ration.
        #       to = hls_cup_tor * max(td, const-to)
        # @remark recomment to 10+ for bad network.
        # default: 1.0
        hls_cup_tor         1.0;
        # how many concurrency core for a origin to use for hls cup.
        # for 0 core, we use sync downloader to fetch hls and segments.
        # for N(>0) core, we use 1 to N concurrency thread per origin to fech.
        #       for example, there are 2origins and 3cores, there will exists 2x3 connection to fetch,
        #       each origin will open 3 connections.
        # @remark only apply when create the downloader(init or retry).
        # @remark recomment the core to 3+ for bad network.
        # default: 0
        hls_cup_core        0;
        # when use hls-cup(core > 1), slice the segment to how many pieces.
        # for example, the slice is 3, a segment will use 3slice which despatch to cores.
        # @remark recomment the slice to segment_size/20KB+ for bad network.
        # default: 3
        hls_cup_slice       3;
        # the timeout in ms to download the m3u8 for hls cup.
        # for example, retry when timeout to download the m3u8.
        # @remark recomment the m3u8 to to 3+ for bad network.
        # default: 2800
        hls_cup_m3u8_to     2800;
        # the timeout ratio to download the ts for hls cup.
        # for example, a ts segment is 10s and slice to 5 pieces, each slice is 2s,
        # when ts_tor is 2.5, the timeout is 2x2.5=5s to download the ts slice.
        # @remark recomment the tor set to td/hls_cup_slice*5+ for bad network.
        # default: 2.5
        hls_cup_ts_tor      2.5;
        # the mrt(max retry times) to download the ts for hls cup.
        # @remark m3u8 will retry this mrt immediately, then sleep a while and retry.
        # @remark recomment the mrt to 10+ for bad network.
        # default: 3
        hls_cup_ts_mrt      3;
    }
}

#############################################################################################
## vhost sections for hls+(streaming hls).
##############################################################################################
vhost hls.plus.bravo.com {
    http_remux {
        enabled     on;
        # the mount can specifies multiple mount points,
        # to remux the RTMP to different stream.
        mount       [vhost]/[app]/[stream].flv [vhost]/[app]/[stream].ts [vhost]/[app]/[stream].m3u8;
    }
    # @remark for hls+ startup, there at least 2s gop cache data.
    play {
        gop_cache       on;
        queue_length    30;
        gop_cache_keyframes     1;
        gop_cache_duration      1;
    }
    # the hls+ section.
    hls_plus {
        # the following is config for hls+, please read full.conf.
        # @remark for pure audio hls+(the vcodec is vn), use 1/2 fragment(atleast 1).
        # @remark the fragment is for fast startup, we will use fragment_better when ok.
        # default: 1
        hls_fragment    1;
        # the better fragment in seconds, for hls+ only.
        # when fast startup, the fragment is small, we will change to this better fragment,
        # @remark set to hls_fragment to use fixed td.
        # @remark when switch to better segment, we will descrease expire.
        # default: 3
        fragment_better 3;
        # default: 5
        hls_window      5;
        hls_m3u8_file   [app]/[stream].m3u8;
        hls_ts_file     [app]/[stream]-[seq].ts;
        hls_acodec      aac;
        hls_vcodec      h264;
        hls_expire      30;
        # @remark the td ratio for hls+ used to verify the segment,
        #       drop when overflow, the td is dynamic changed, not like hls.
        # default: 30
        hls_td_ratio    30;
        # default: 1.0
        hls_aof_ratio   1.0;
        
        # @remark when fragment smaller than 2, always off.
        # @remark when enabled, we will switch to keyframe by switch_keyframe.
        #       ignore when switch_keyframe not enabled.
        # @remark when switch to keyframe, we will increase the aof_ratio, descrease expire.
        # @remark ignore for pure audio hls.
        # default: off
        hls_wait_keyframe       off;
        # the time in seconds to switch to keyframe.
        # @remark ignore when hls_wait_keyframe is off.
        # @remark ignore switch to keyframe mode if -1.
        # @remark ignore for pure audio hls.
        # default: 120
        switch_keyframe     120;
        
        # the timeout in seconds for a session, should >= hls_window.
        # when client not request the virtual connection(the session), disconnect the session.
        # default: 30
        session_timeout 30;
        # whether use ip location,
        # if on, redirect to ip m3u8 to avoid edge jump by dns.
        # if off, redirect to the original url by client request.
        # default: on
        ip_location     on;
        # the identify method for hls+,
        #       302, use HTTP302 to identify the client.
        #       variant, use variant HLS to identify the client.
        # when client specifies the shp_identify, use it, for example:
        #       http://localhost:8080/live/livestream.m3u8?shp_identify=302
        #       http://localhost:8080/live/livestream.m3u8?shp_identify=variant
        # @remark apply config, then apply query.
        # default: 302
        identify        302;
        # how many small ts to tranmux for fast startup. 0 to ignore.
        # @remark user can use query "shp_stage=safari" to m3u8 to use safari multiple stages(fst=5,st=4)
        # @remark user can use query "shp_fst=5" to transmux fst small segments
        # @remark for safari, bms system default value is 2.
        #         for android, vlc, curl, benchmark, bms system default value is 1.
        #         for flash with shp_xpsid, bms system default value is 1.
        #         for flash without shp_xpsid, bms system default value is 2.
        # @remark for others, bms system default value is 1.
        # @remark apply system default value, then apply query, then apply config.
        # default: 0
        fast_startup_ts 0;
        # how many ts should wait for the first m3u8. 0 to ignore.
        # @remark user can use query "shp_st=5" to serve request util got st segments
        # @remark for safari, bms system default value is 2.
        #         for android, vlc, curl, benchmark, bms system default value is 1.
        #         for flash with shp_xpsid, bms system default value is 1.
        #         for flash without shp_xpsid, bms system default value is 2.
        # @remark for others, bms system default value is 1.
        # @remark apply system default value, then apply query, then apply config.
        # default: 0
        startup_ts      0;
        # for variant identify, the BANDWIDTH of #EXT-X-STREAM-INF of HLS.
        #       #EXT-X-STREAM-INF:BANDWIDTH=3000000
        # @remark please read "Basic Variant Playlist" of https://developer.apple.com/library/ios/technotes/tn2288/_index.html
        # default: 3000000
        ext_bandwidth   3000000;
        # when 302 the m3u8 to lock the user to edge,
        # we will specifies the vhost in query string domain/vhost,
        # but upyun need to specifies the vhost b4(before) the app, 
        # that is: http://ip:port/vhost/app/stream.m3u8
        # @remark always be true when upyun cluster on.
        # default: off
        vhost_b4_app    off;
        # when ip_location on, whether force to use bms http port.
        # for example, nginx proxy the http request to bms, while flash requrires the 
        # crossdomain.xml, when user 80 port, maybe the nginx not support request without domain.
        # @remark use global f4_hls_plus_port when not 0.
        # @remark always on when upyun cluster on.
        f4_bms_port     off;
        # we can set url scheme in the url for redirect and the url of ts file in m3u8 file.
        # cooperating with other system, we can jus change the url scheme into "https" to achieve https.
        # @remark bms has not supported https.
        # default http.
        url_scheme http;
        # the CORS for hls+ for videojs.
        # @read http://dev.chnvideo.com:3000/issues/5373
        crossdomain {
            # whether enable the CROS for http stream.
            # default on
            # TODO: FIXME: change to off, when bitch online.
            enabled on;
            # the domain to allow CROS.
            # default: *
            domains *;
            # the methods to allow CROS.
            # default: GET
            methods GET;
        }
    }
    publish {
        # for the hls to not parse the sps pps.
        parse_sps   on;
    }
}
vhost hls2.plus.bravo.com {
    http_remux {
        # for the http_remux generally for edge,
        # that is the hstrs always be true, and it's ok for origin,
        # so, we removed it in SRS3+.
        #hstrs       on;
    }
}

#############################################################################################
## additional option in play section
##############################################################################################
vhost metadata.play.vhost.bravo.com {
    play {
        # whether the metadata property is readonly.
        # when on, bms directly transmit the metadata without modify
        # when off, bms will modify metadata
        # default: off
        metadata_readonly       off;
    }
}
vhost gop.play.vhost.bravo.com {
    play {
        gop_cache               on;
        
        # gop.keyframes
        # how many keyframes(I frame) to keep in cache when gop cache enabled.
        # when keep 1 keyframe, only cache the current gop.
        # when keep 2 keyframe, cache current and previous gop, etc.
        # @remark the more keyframes in gop cache, the faster when startup and large latency.
        # @remark server will clear gop cache when exceed 60s.
        # default: 1
        gop_cache_keyframes     2;
        
        # gop.duration
        # how many meessages should keep in gop cache in seconds.
        # for example, audio only stream can use this as gop cache without keyframes.
        # and hls+ can use this to ensure there are data in gop cache for fast startup.
        # default: 1
        gop_cache_duration      1;

        # just store video in gop
        # to reduce the delay and also make sure the video start fast,
        # we need to just store the video in gop.
        # default: off
        gop_cache_just_video off;
    }
}
vhost timebase.play.vhost.bravo.com {
    play {
        # whether correct the audio/video to the same timebase
        # default: off
        timebase_correct    off;
        # atc flag, @see full.conf
        atc                 off;
        # mix correct flag, @see full.conf
        mix_correct         off;
        # time jitter, @see full.conf
        time_jitter         full;
    }
}

#############################################################################################
## additional option in publish section
##############################################################################################
vhost publish.drop.vframe.com {
    publish {
        # whether drop the video frame whose header is unknown.
        # in the header of video for flv, the frame type shoule be 1 to 5, codec id should be 1 to 7.
        # but some encoders do not obey this rule, so we should decide whether to check the video frame.
        # default: on.
        drop_unknown_vframe on;
    }
}

#############################################################################################
## additional option in http hooks section
##############################################################################################
vhost hooks.vhost.bravo.com {
    http_hooks {
        enabled         on;
        # add query to request:
        #       {
        #           "query": "token=xxxx&id=xxxx&xpid=xxxx"
        #       }
        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;
    }
}

#############################################################################################
## bravo vod server section, remux vod file to hls.
##############################################################################################
# inject the flv:
#       ./research/librtmp/objs/srs_flv_injecter doc/source.200kbps.768x320.flv objs/nginx/html/source.flv
# user can access the vod stream by:
#       http://localhost:8080/source.m3u8
# which will remux from ./objs/nginx/html/source.flv
# @reamrk see conf/bravo_vod.conf
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
}
vhost http.vod.bravo.com {
    http_vod {
        # whether http vod is enabled.
        # default: off
        enabled     on;
        # the vod can support multiple extensions
        exts        .m3u8;
        # the hls fragment in seconds, the duration of a piece of ts.
        # default: 3
        hls_fragment    3;
    }
}

#############################################################################################
## FLS(FLV Live Streaming) for Akamai
##############################################################################################
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
}
vhost fls.vhost.bravo.com {
    # FLS(FLV Live Streaming) for Akamai
    # @remark we write file to memory not to disk.
    fls {
        # whether enabled the fls(flv live streaming) for akamai.
        # default: off
        enabled on;
        # the segment duration in 1/10 seconds.
        # default: 5
        fls_segment 5;
        # the window in 1/10 seconds.
        # default: 300
        fls_window 300;
        # the metadata mount path.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        # default: [vhost]/[app]/[stream]/live.flv
        # @remark should not contains '-' in path.
        # @remark the dirname(metadata) should equals to dirname(file)
        # @remark player should request with query m=fls to distinct with flv streaming.
        fls_metadata    [vhost]/[app]/[stream]/live.flv;
        # the flv pieces file path.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], replace this const to current minute.
        #       [05], replace this const to current second.
        #       [seq], seq=sts/100/fls_segment, sts is stream timestamp in ms.
        # @see https://github.com/ossrs/srs/wiki/v2_CN_DVR#custom-path
        # @see https://github.com/ossrs/srs/wiki/v2_CN_DeliveryHLS#hls-config
        # default: [vhost]/[app]/[stream]/[2006]-[01]-[02]-[15]-[04]-[05]-[seq].flv
        # @remark there must be a '-' in the file, to distinct with the fls_metadata.
        # @remark the dirname(metadata) should equals to dirname(file)
        # @remark when exceed the sts, server will response error code and sts, client should retry.
        #       for cdn, client should retry with query util success.
        # @remark player should request with query m=fls to distinct with flv streaming.
        fls_file        [vhost]/[app]/[stream]/[2006]-[01]-[02]-[15]-[04]-[05]-[seq].flv;
    }
}

#############################################################################################
## Rewriter section, to switch edge to multile upstreams.
##############################################################################################
# The bellow is the usage for rewriter.
# 1. Start edge and two origin(cdn and blackhole).
#           ./objs/srs -c conf/bravo_rewriter_cdn.conf
#           ./objs/srs -c conf/bravo_rewriter_blackhole.conf
#           ./objs/srs -c conf/bravo_rewriter.conf
#       For demo, the edge ingest two streams to itself and forward to upstream.
# 2. Open js page to rewrite the rule.
#       http://127.0.0.1:8080/players/rewrite.html
# 3. Play the stream on cdn, the stream will be switched.
#       http://www.ossrs.net/players/srs_player.html?app=live_panda&stream=1dc18ea440809bab10ec1465769146ce.flv&server=127.0.0.1&port=8081&autostart=true&vhost=pl99.live.panda.tv&schema=http
# 4. Play the stream on blackhole, the administrator can preview the standby stream.
#       http://www.ossrs.net/players/srs_player.html?app=live_panda&stream=1dc18ea440809bab10ec1465769146ce.flv&server=127.0.0.1&port=8082&autostart=true&vhost=pl99.live.panda.tv&schema=http
# The rewrite API modify the ruler and apply it.
# @remark we will drop video frame util got the I frame when switch.
vhost switch.bravo.com {
    cluster {
        mode remote;
        origin 127.0.0.1:1936 127.0.0.1:1937;
        vhost pl99.live.panda.tv;
    }
    
    # The rule to rewrite stream, format is:
    #       rewrite match {}
    # Where the match is the stream(without vhost) to rewrite. 
    rewrite live/live_panda/1dc18ea440809bab10ec1465769146ce {
        # whether enable this rewrite.
        # default: off
        enabled off;
        # For this stream, change the origin server.
        # @remark ignore for empty string.
        origin 127.0.0.1:1936;
        # For this stream, change the stream url.
        # @remark ignore for empty string.
        stream live_panda/1dc18ea440809bab10ec1465769146ce;
    }
    
    # another rule for stream.
    rewrite fake/live_panda/1dc18ea440809bab10ec1465769146ce {
        enabled off;
        origin 127.0.0.1:1937;
        stream live_panda/1dc18ea440809bab10ec1465769146ce;
    }
    
    # we use gop cache for rewrite,
    # so, the play.gop_cache* is also available for it.
    # TODO: refine for the edge to use isolate gop cache.
    play {
        gop_cache       on;
        gop_cache_keyframes     1;
    }
}

#############################################################################################
## play edge settings to ingest stream from upstream.
##############################################################################################
# user can set the interval to retry faster, for example, some customers may trigger the
# publish by play stream from edge, so the edge will failed for the first time for there is
# no stream exists in bocar, and it spent long time(about 9s) to retry where player will
# wait for 9s to start to play. the player will start faster when the retry interval change
# to smaller for instance 1s.
vhost play.edge.bravo.com {
    cluster {
        mode    remote;
        origin  127.0.0.1:1935;
        # time for edge ingest retry in millisecond
        # @remark this time should not be less then 1 second(1000 ms)
        # default: 6000
        edge_ingest_retry_interval      2000;
        # times for edge ingest
        # @remark should be larger than 0
        # default: 3
        edge_ingest_retry_times         3;
    }
}

#############################################################################################
## Forbidden section, to forbid the publish.
##############################################################################################
# when client publish, call the api to check whether the stream forbidden.
# if the stream is forbidden, disconnect the client.
# The below the is the usage for forbidden.
# 1. Start the upyun-server.py:
#       python research/api-server/upyun-server.py 8086
# 2. Start the bms:
#       ./objs/srs -c conf/bravo_forbidden.conf
# 3. publish stream to:
#       rtmp://localhost:1935/live/stream?vhost=forbidden.bravo.com
# For demo, the stream will be forbidded.
vhost forbidden.bravo.com {
    forbidden {
        # whether forbidden is enabled.
        # defautl: off.
        enabled     on;
        # the api to query the stream if forbidden
        # when user publish stream, call the api,
        # the request in the POST data string is an object encode by json:
        #   {
        #       "domain": "forbidden.bravo.com",
        #       "app": "live",
        #       "stream": "livestream",
        #       "ip": "192.168.1.123",
        #       "tcUrl": "tcUrl",
        #       "pageUrl": "pageUrl",
        #       "swfUrl": "swfUrl",
        #       "schema": "schema",
        #       "host": "host",
        #       "param": "param",
        #   }
        # the api response data is a object encode by json:
        #   {
        #       "code": 0,
        #       "data": {
        #           "forbidden": true   // whether the stream is forbidden
        #       }
        #   }
        # if forbidden is true, the stream is forbiddened, disconnect it.
        api         http://localhost:8086/api/v1/forbidden_streams;
    }
}

#############################################################################################
## Token section, to check the publish url if permission.
##############################################################################################
# when enable the token, bms will check the publish url if permission.
# for example: when publish: rtmp://localhost:1935/live/stream?domain=token.bravo.com&token=dc271a36213bdba8ce60b6ff164c64d5&expired_ts=1497430634
# bms will generate token, and check if it is equal with urls' token. function for generate token is md5(vhost/app/streamexpired_tssalt),
# if the generate token is equal with 43849aae4a20e53402c0c3ed48789b4c, publish success, else bms will disconnect the publish client.
# for salt, if user set the api, bms will prior get it from the api; if api empty, bms will use the default salt.
# user can publish without api, and use default salt www.chnvideo.com:
#     rtmp://localhost:1935/live/stream?vhost=token.bravo.com&token=0b477bab5da82a76a68b5a22c9b88223&expired_ts=1497430634
vhost token.bravo.com {
    token {
        # whether enable the token
        # default: off
        enabled     on;
        # BMS apply the token to play or publish
        # default: publish
        apply       play publish;
        # the strategy for check token.
        # blss: bravo live streaming service
        # QiNiu: upyun customer qiniu. for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-qiniu
        # CC: upyun customer cc. for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-cc
        # FuYun: upyun customer Fuyun, for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-fuyun
        # CSCloud: upyun customer CSCloud, for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-cscloud
        # YunKe: upyun customer YunKe, for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-yunke
        # PA: upyun customer pa, for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-qa
        # YSY: upyun customer ysy, for detail, @see: https://github.com/laolei2016/bms4upyun/blob/api/develop/Security.md#token-ysy
        # default: blss
        strategy     blss;
        # token valid duration in minutes
        # @remark only for strategy CC.
        # default: 2880(48h).
        duration    2880;
        # blss: when user publish to this vhost, bms will call the api to get the salt
        # the response data is an object encode by json:
        # {
        #     "code": 0,
        #     "data": {
        #         "salt": "a1b2c3d4e53gxwb07"
        #     }
        # }
        # @remark, for blss: when api empty, use the default salt.
        # FuYun: callback the api to check token by GET.
        # @remark, for FuYun: the api should not be empty.
        # CSCloud: callback the api to check the token by POST.
        # @remark, for CSCloud: the api should not be empty.
        # YunKe: callback the api to check rtmp token by GET.
        # @remark, for YunKe: the api should not be empty.
        # default: empty
        api         http://127.0.0.1:8086/api/v1/tokens?domain=[domain];
        # when api empty, use this.
        # @remark: if salt empty, bms will return error for check token failed.
        salt    www.chnvideo.com;
        # the mode of token check.
        # there are two ways to check:
        #   1. local, check token inside bms.
        #   2. bss, send information to bss. Bss do check and send the result back to bms.
        # default: local
        mode local;
    }
}


#############################################################################################
## bravo bar(bravo application-level route) section
##############################################################################################
# when edge connect the origin/transfer to push/pull stream, may be there are many origins that edge can
# connect, the bar will choose the best one for edge to push/pull stream
bar {
	# whether enabled the bar.
	# default: off
	enabled		off;
	# the api server for bar to query origin
	api			http://127.0.0.1:2034/api/v1/bar;
	# the bar(bravo application-level route) startup command.
	# server will fork a process to run the api and quit when it terminated.
	# @remark user can specifes the stdout and stderr by 1>file and 2>file.
	bar			./objs/bravo_bar --listen=127.0.0.1:2034 1>/dev/null 2>/dev/null;
}


#############################################################################################
## bravo sc(bravo stream check) section
##############################################################################################
# SC is part of bravo HotlinkDenial.
# When being enabled, SC will check whether the app/stream in request for both play and publish is legal
vhost streams.bravo.com {
    stream_check {
        # whether check the app/stream
        # default: off
        enabled off;
        # the stream check verify api, outer system support and bms call the api
        api http://127.0.0.1:8086/api/v1/stream_check?domain=[domain]&app=[app]&stream=[stream]
    }
}

#############################################################################################
## RTMP/HTTP VHOST sections
##############################################################################################

# the vhost scope configs.
vhost scope.vhost.srs.com {
    # The input ack size, 0 to not set.
    # Generally, it's set by the message from peer,
    # but for some peer(encoder), it never send message but use a different ack size.
    # We can chnage the default ack size in server-side, to send acknowledge message,
    # or the encoder maybe blocked after publishing for some time.
    # Default: 0
    in_ack_size     0;

    # The output ack size, 0 to not set.
    # This is used to notify the peer(player) to send acknowledge to server.
    # Default: 2500000
    out_ack_size    2500000;
}

#############################################################################################
## bravo swf token section
##############################################################################################
vhost swf.bravo.com {
    # whether enable the swf check
    # default: off
    swf_check {
        # whether enable the swf check
        # default: off
        enabled     off;
        # the api to get the swf content
        api         http://127.0.0.1/api/v1/swf;
    }
}

#############################################################################################
## bravo pass param to origin when playing a stream 
##############################################################################################
vhost play.param.com {
    cluster {
        # whether pass the params in rtmp url to origin when playing a stream.
        # Default off
        pass_play_param on;
    }
}

#############################################################################################
## send http-flv in chunked or unchunked way
##############################################################################################
vhost http.flv.chunked {
    http_remux {
        # whether send http-flv in chunked way
        # Default: on
        flv-chunked off;
    }
}
clu